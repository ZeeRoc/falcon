ipv.vulnerability = {
    module: 'vulnerability',
    version: 'v0.1',
    COMMAND: {
        CMD_SCAN: {
            cmd: 'scan_vulnerability'
        },
        CMD_FIX:{
            cmd:'fix_vulnerability',
            vulIDs:[],
            softVulIDs:[]
        },
        CMD_STOP: {
            cmd: 'stop_process_vulnerability'
        },
        CMD_IGNORE:{
            cmd:'ignore_vulnerability',
            IDs:[],
            isPermanent:false
        },
        CMD_CANCEL_IGNORE:{
            cmd:'ignore_vulnerability',
            IDs:[],
            isPermanent:true
        },
        CMD_GET_IGNORED: {
            cmd: 'get_ignored_vulnerability'
        },
        CMD_GET_FIXED: {
            cmd: 'get_fixed_vulnerability'
        },
    },
    flag:false,
    fmt: (CMD) => {
        return JSON.stringify(CMD) + ';\n';
    }
};
ipv.vulnerability.callback = {
    Scan: () => {
            ipv.CLIENT.send(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_SCAN));
    },
    Fix: () => {
            ipv.CLIENT.send(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_FIX));
    },
    Stop: () => {
            ipv.CLIENT.send(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_STOP));
    },
    Ignore: () => {
            ipv.CLIENT.send(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_IGNORE));
            console.log(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_IGNORE))
    },
    CancelIgnore: () => {
            ipv.CLIENT.send(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_CANCEL_IGNORE));
    },
    GetIgnored: () => {
            ipv.CLIENT.send(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_GET_IGNORED));
    },
    GetFixed: () => {
            ipv.CLIENT.send(ipv.vulnerability.fmt(ipv.vulnerability.COMMAND.CMD_GET_FIXED));
    },
    task_detail: (task) => {
            switch (task.cmd) {
                case 'scan_vulnerability_cmd_received' :
                    if(!task.isSuccess){
                        // 扫描失败
                        return;
                    }
                    break;
                case 'vulnerability_scan_started':
                    ipv.vulnerability.view.drawView('漏洞', 'begin');
                    ipv.vulnerability.view.viewAdapter({ path: '' });
                    
                    // ipv.vulnerability.view.fix_stoped()
                    
                    break;
                case 'vulnerability_scan_progress':
                    ipv.vulnerability.view.viewAdapter({ path: '正在扫描第'+task.currentItem+'项' });
                    break;
               case 'vulnerability_scan_on_scan_item':
                    ipv.vulnerability.flag = true;
                    ipv.vulnerability.view.FoundVirus(task);
                    break;
                case 'vulnerability_ignored':
                    ipv.vulnerability.view.RemoveItems(task.IDs);
                    console.log(task.IDs);
                    break;
                case 'engine_scan_started':
                    ipv.vulnerability.view.drawView(ipv.vulnerability.ScanStatus[ipv.vulnerability.scanType], 'begin');
                    break;
                case 'vulnerability_scan_stopped':
                    if (ipv.vulnerability.view.forceStop && !ipv.vulnerability.flag) {
                        console.log('force')
                        ipv.vulnerability.view.drawView(null, 'end')
                    } else {
                        ipv.vulnerability.view.ScanEnd();
                    }
                    ipv.vulnerability.view.ProgressBar(0, task.cmd);
                    break;
                case 'engine_suspended':
                case 'engine_resumed':
                    console.log(task);
                    ipv.vulnerability.view.Pause(task.cmd);
                    break;
                default:
                    break;
            };
    }
}